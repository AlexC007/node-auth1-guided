//----------------------------------------------------------------------------//
// the router exported from this file is bound to /auth by the api-router (which
// is bound to /api). The full url that this router is bound to is /api/auth.
//----------------------------------------------------------------------------//

const router = require('express').Router();
// we need bcrypt imported in order to use it...
const bcrypt = require('bcryptjs');
// this is our credentials validation method:
const authorize = require('./auth-required-middleware.js');

// this is the users model, with methods that access the database through knex.
// This allows us to look users up, add them to the database, etc.
const Users = require('../users/users-model.js');

//----------------------------------------------------------------------------//
// POST /api/auth/register
//
// in this method, we extract the user object info from the req.body. we then
// hash the password using bcrypt and store the hash on the user object before
// passing it in to Users.add, so it's the *hash* that is stored in the DB, not
// the plain text password.
//
// note that the hash is a hash of the user's password, plus a "salt" string.
// Salt is a random string that is appended to the password before the hashing
// algorithm is executed. The salt can be provided by you, or you can allow
// bcrypt to generate a salt string automatically (this is the default).
//
// in this way, the hash that we put in our database is not easily recognizable.
// Someone with a "rainbow table" can't do a simple lookup for the hash you have
// stored. (A rainbow table is a list of pre-computed hashes that they can use
// to try to look up a password, after they gain unauthorized access to  your
// database)
//
//----------------------------------------------------------------------------//
router.post('/register', (req, res) => {

  let user = req.body;
  // the format of this hash is [version][cost][salt][hash]. see
  // https://en.wikipedia.org/wiki/Bcrypt for more info. "cost" is a factor that
  // indicates how many times the hash algorithm should be run. The hash
  // algorithm is computationally expensive, so every additional run takes
  // longer and longer. A cost factor of 3 is twice is long as a cost factor of
  // 2... 2^cost is the number of times the algorithm is executed. The salt is
  // randomly generated by bcryptjs by default. The salt and the cost factor are
  // stored with the hash, so when bcrypt is asked to "compare" a password
  // "guess" to this hash (which means it will try to recompute the hash using
  // teh password guess, and compare the newly-computed hash with the original
  // hash), it will have the same salt that was originally used, and the same
  // cost factor. Without these, together with the correct password, it would
  // not be able to generate the same hash. (Note that there are multiple
  // versions of the algorithm that bcrypt uses, and the version indicator is
  // also saved with the hash, so it is sure to use the right version.)
  const hash = bcrypt.hashSync(user.password, 8);
  user.password = hash;

  Users.add(user)
    .then(saved => {
      res.status(201).json(saved);
    })
    .catch(error => {
      res.status(500).json(error);
    });
});

//----------------------------------------------------------------------------//
// note that "401" is the proper HTTP result code to send if someone is not
// authenticated. This is what you will find with typical REST-based API's.
// Thus, developers using *your* API are likely to expect this.
//
// If someone *is* authenticated, but doesn't have *permission* to access what
// they are trying to access, you should respond with a 403.
//
// see https://restfulapi.net/http-status-codes/ see
// https://www.restapitutorial.com/httpstatuscodes.html 
//
//
// we use the authorize middleware method from ./auth/auth-required-middleware.js to
// validate the credentials. If the credentials are bad, the validate() method
// will respond with a 401 before our handler here is able to process.
// 
// NOTE: In class, I said that we would not want to use this validation method
// on login... I mispoke! We can use it to actually do the work of validating
// the credentials. But note that the credentials MUST be passed in headers, or
// login will fail (because authorize() will not find the credentials, since it
// looks for them in headers...) This way, our login method is nothing more than
// responding with success... It will never be able to respond with success if
// the credentials are missing or invalid, because authorize() will respond with
// a 401.
//
//----------------------------------------------------------------------------//
router.post('/login', authorize, (req, res) => {
  // we wouldn't even be executing this line if the credentials were missing or
  // bad... authorize() will see to that. 
  let { username } = req.headers;
  res.status(200).json({ message: `Welcome ${username}!` });
})

//----------------------------------------------------------------------------//
// this is the original login method, without authorize()
//----------------------------------------------------------------------------//
// router.post('/login', (req, res) => {
//   let { username, password } = req.body;
//
//   Users.findBy({ username })
//     .first()
//     .then(user => {
//       if (user && bcrypt.compareSync(password, user.password)) {
//         res.status(200).json({ message: `Welcome ${user.username}!` });
//       } else {
//         res.status(401).json({ message: 'Invalid Credentials' });
//       }
//     })
//     .catch(error => {
//       res.status(500).json(error);
//     });
// });

module.exports = router;
